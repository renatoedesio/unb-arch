\documentclass{sig-alternate-05-2015}
  \pdfpagewidth=8.5truein
  \pdfpageheight=11truein
  
  \usepackage{graphicx}
  \usepackage[portuguese, english]{babel}
  \graphicspath{ {images/} }
  \usepackage[utf8]{inputenc}
  \usepackage[justification=centering]{caption}
  \usepackage{amsmath}
  \usepackage{multirow}
  \usepackage{makecell}
  \usepackage{cite}
  \usepackage{booktabs}
  \usepackage{changes}
  \usepackage{enumerate}
%  \usepackage{subfigure}
\usepackage{caption}
\usepackage{subcaption}
\begin{document}

% Copyright
\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
\doi{http://dx.doi.org/xx.xxxx/xxxxxxx.xxxxxxx}

% ISBN
\isbn{978-1-4503-3739-7/16/04}

%Conference
%\conferenceinfo{PLDI '13}{June 16--19, 2013, Seattle, WA, USA}

\acmPrice{\$15.00}

%
% --- Author Metadata here ---
\conferenceinfo{SAC'16,}{ April 4-8, 2016, Pisa, Italy}
\CopyrightYear{2016} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{Exploring the Combination of Software Visualization and Data Clustering in the Software Architecture Recovery Process}


\numberofauthors{1} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor
Renato Paiva, Genaína N. Rodrigues, Marcelo Ladeira,  Rodrigo Bonifacio\\
       \affaddr{Computer Science Department}\\
       \affaddr{University of Brasília}\\
       \affaddr{Brasilia, Brazil}\\
       \email{\{renatoedesio, mladeira, rbonifacioatcic\}@unb.br,\\
       genaina@cic.unb.br}
}

\maketitle
\begin{abstract}
	Modernizing a legacy system is a costly process that requires deep understanding of the system architecture and its components. Without an understanding of the software architecture that will be rewritten, the entire process of reengineering can fail. When there is absence of architectural documents, it is important to have a recovery process of architecture that allows the complete understanding of the software. Such process involves mapping of source code entities in high-level models. \replaced{Previous work using quasi-automatic and quasei-manual techniques for architecture recovery has been proposed and extensively used. However, there is still important improvements that need to be addressed based on this theme.}{Previous work using visualization and clustering techniques has been proposed and extensively used. However, their accuracy to reconstruct the architecture alone has shown to be not satisfactory enough.} Thus, this work proposes to explore if an approach where visualization and clustering applied together can provide a higher accuracy on the software architecture recovery process. An experimental study was conducted to empirically evaluate our investigation. The results indicated a statistically significant increase in the accuracy of the models produced.
\end{abstract}


%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>  
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}


%
% End generated code
%

%
%  Use this command to print the description
%
\printccsdesc

% We no longer use \terms command
%\terms{Theory}

\keywords{Software Architecture Recovery; Software Visualization; Data Clustering}

\input{introduction.tex}

\section{RELATED WORK}%


%\deleted[remark={levar para a secao de trabalhos relacionados}]{Wettel \textit{et al.} \cite{wettel_software_2011} carried out a controlled experiment to investigate the 
%efficacy and effectiveness of the CodeCity software visualization tool in the process of understanding a software system structure. 
%Results pointed out that, using such tool, it was possible to obtain an accuracy of 24.26\% and a reduction of 12.01\% in the execution time of a 
%certain number of tasks, when compared to an understanding process carried out via a manual inspection of the source code.}

The maintenance and evolution of systems is expensive and involves a high risk, which is due to the difficulty of understanding the system architecture. To solve this problem, several approaches for the recovery of software architecture have been proposed. Ducasse et al. in \cite{ducasse_software_2009} present a taxonomy of approaches to architecture recovery, detailing information necessary for recovery, such as: what are the stakeholders’ goals, how does the general reconstruction proceed, what are the available sources of information, based on this, which techniques can we apply, and, finally, what kind of knowledge does the process provide.

Software visualization provides complementary perspectives on the analyzed system. Through the use of software visualization, it is possible to explore the software architecture through representations based on diagrams "box-line", interconnected graphs, dependency matrices etc. These artifacts represent interactions between the modules in the system and can combine different metrics to increase the level of information of each diagram \cite{ lungu_lanza_2007}.

Lanza in \cite {lanza_codecrawler-lessons_2003} presents a tool that focuses on the software visualization. This tool supports reverse engineering through combinations of metrics and software visualization techniques. The author makes use of the concepts of polymetric views to facilitate the understanding of the software. In this type of view it is possible to have notions of how, when and what metric a specific class was represented. Figure \ref{printScreenCodeCrawler} highlight the main screen of CodeCrawler tool.

The works of Sangal \cite{Sangal_2005} and Tekinerdogan \cite{Tekinerdogan_2009}  are focused on representation of the source code in graphs and matrix structured dependencies, to create the system architecture of understanding of software. By analyzing such artifacts extracted through code static analysis, they show how to detect structural elements of the system and get an understanding of its architecture.

Regarding the use of data clustering for understanding software systems, the tool developed by Mancoridis \textit {et al.} \cite {Mancoridis_1999}  has a notable highlight. Through that tool it is possible to automatically create breakdowns of the system structure in significant subsystems. The processed data can provide structural information to developers, facilitating the understanding of software components, their interfaces and interconnections. The tool provides a complete environment for the clustering process; implemented through a tool with a graphical interface and made available for free, with operating manual and sample code.

Another approach to the understanding of software systems by using data clustering techniques was presented by Tzerpos \textit{et al.} \cite {Tzerpos_vassilios}. In their study, it is presented a clustering algorithm that discovers clusters that follow patterns that are commonly observed in decompositions of large software systems that were prepared manually by their system architects.  Also, the algorithm assign meaningful names for cluster generated. 


\section{RATIONALE ON THE COMBINATION BETWEEN VISUALIZATION AND DATA CLUSTERING}%

In many cases, the analyst, with some knowledge of a system, can perform an analysis of the results and create a concise final model. However, especially for complex systems, it is necessary to use strategies for interpretation of results. Such strategies involve the observation of repeated patterns and identification of architectural violations in the source code.

In general, automatic architecture reconstruction methods, such as clustering technique, has the advantage to produce different models for a single software system in a short period of time. Such models can be constructed differently by changing configuration settings on clustering algorithm used during the process. Through the analysis of different models it is possible to identify patterns that recur frequently in the results.

However, when the idea is not clear of how the system structure is composed, the various models produced by clustering process can not help to understand complex software \cite{craft}, since the results show a high level view of the architecture. In this sense, the use of software visualization technique permit an observation of different outcomes on a low level of abstraction. By means of interactive operations in the models produced by the visualization software, it is possible to decompose components of the system in more detailed representations. Thus, allowing the observation of concepts as part of the architecture in greater depth.

In this context, linking the models produced by the clustering process with the model produced by the software visualization process, it is possible to get different representations of the system to form a final model with greater precision. For example, take into account the results shown in Figure \ref{exemplo_comparacao_modelos}. Assuming that the process of obtaining architecture models recovered four different results, through the use of software visualization technique and clustering algorithms. Each model features 9 entities, namely: \{1,2,3,4,5,6,7,8,9\}. By performing a count of the grouped entities it is  possible to obtain the ratio of how many times the entity was classified similarly to the other. The result of this count is observed in Table \ref{ocorrencias_1}.

\begin{table}[]
	\centering
	\caption{Occurrences of entities in the results.}
	\label{ocorrencias_1}
	\begin{tabular}{|cc|}
		\hline
		\multicolumn{1}{|l}{Relation} & \multicolumn{1}{l|}{Occurrence} \\ \hline
		\{1,2,3\}                   & 100\%                           \\
		\{1,2,3,4\}                 & 25\%                            \\
		\{4,5\}                     & 50\%                            \\
		\{4,5,6\}                   & 25\%                            \\
		\{5\}                       & 25\%                            \\
		\{6\}                       & 25\%                            \\
		\{6,7,8,9\}                 & 50\%                            \\
		\{7,8,9\}                   & 100\%                           \\ \hline
	\end{tabular}
\end{table}

By analyzing the results, it is possible to see that the entities \{1,2,3\} can be classified into a single module, since they appear 100\% of the times in the same relation; so do the entities \{7,8,9\}. The entities \{4,5,6\} may be classified as either a single module or each entity may be added to any other adjacent module, since there is no agreement between the results. In these cases, additional analysis must be performed for each entity. This simple example illustrates how to use different results to help the composition of a single final model. In many cases, the aggregation of results provide technical assistance, by highlighting the common patterns. It is possible to gain confidence that agreement across a collection of results can reflect the system structure \cite {craft}.

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.43\textwidth]{exemplo_comparacao_modelos_en}
	\caption{Different results for comparison.}
	\label{exemplo_comparacao_modelos}
\end{figure}


However, a more careful analysis of the results, may reveal that other factors may influence the final model produced by clustering and visualization software techniques. A software system throughout its life cycle is susceptible to several changes in its architecture. However, such operations can introduce architectural violations in the code, for example, violation of the layers,  break of abstractions, feature duplication \cite {kazman_view_1998}. In this context, reverse engineering methods are strongly affected by those shortcomings in the system code base \cite {Platenius_2012}.  Such violations should be identified and addressed, so it does not affect the correctness of the final model.

To illustrate a violation on an architecture,  we will use the same results of Figure \ref{exemplo_comparacao_modelos}.  This Figure illustrates a representation of an architecture components through a dependency structure matrix. The figures depicts how the interaction works. The software elements are numbered from 1 to 4, where, for example, the Presentation module (2) requires information from the Visualization module (1). On the other hand, the figures shows also that the Visualization module (1) provides information to the Data module (4).

 \begin{figure}[!h]
 	\centering
 	\includegraphics[width=0.42\textwidth]{3_exemploMatrizViolada_en}
 	\caption{DSM representation	of dependences.}
 	\label{3_exemploMatrizViolada}
 \end{figure}
 
 Assuming the entity 4 is wrongly mapped as part of a module. This happens due to a coupling between entities 4 and 5, which illustrates an architecture violation. All results would be classified differently if such violation was removed, as shown in Figure \ref{exemplo_comparacao_modelos2}. The results of the new analysis, taking into account the aggregation of similar entities, can be seen in Table \ref{ocorrencias_2}. Analyzing the results, it is possible to check the impact of the violation. The module containing the first mapping \{1,2,3\} now adds  entity 4, since this set was rated similarly on all results. As for the mapping \{5,6\} there is also a higher chance of being classified in a same module, as it occurs with higher frequency.


\begin{table}[]
	\centering
	\caption{Occurrences of entities between the results after elimination of architectural violation}
	\label{ocorrencias_2}
	\begin{tabular}{|cc|}
		\hline
		\multicolumn{1}{|l}{Relation} & \multicolumn{1}{l|}{Occurrence} \\ \hline
		\{1,2,3,4\}                   	  & 100\%                           \\
		\{5\}                			  & 50\%                            \\
		\{5,6\}                    		  & 50\%                            \\
		\{6\}                 			  & 25\%                            \\
		\{6,7,8,9\}                       & 25\%                            \\
		\{7,8,9\}                         & 100\%                            \\ \hline
	\end{tabular}
\end{table}

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.43\textwidth]{exemplo_comparacao_modelos_2_en}
	\caption{Eliminating the architectural violation of results.}
	\label{exemplo_comparacao_modelos2}
\end{figure}

Such violations can be found through an analysis of the artifacts produced by software visualization. As an example, take into account the dependency structure matrix shown previously in Figure \ref{3_exemploMatrizViolada}. Through observation of the DSM, it is possible to note a relationship exists between layers, and each layer depends on the upper layers. However, this relationship is violated by layer "Date" (4), since it uses resources of the layer  "View" (1), characterizing an architectural violation. Once the violation is detected, it should be treated as failure and, if necessary, modify the data set for the clustering process, so that the relationship is not considered. Thus, avoiding the production of wrong models that may affect the interpretation of the results.

\input{experiment.tex}



\section{CONCLUSION}
One of the factors that can influence the success or failure of a process of legacy system modernization is the understanding of its architecture. In this sense, the time taken to recover these concepts is as important as the time spent in planning the new system. This is due to the fact that, for a complete understanding of a legacy system, the first step is to understand its architecture, because this is the base that supports all system features. Thus, for the architecture recovery process as complete and accurate as possible, it is essential the use of different techniques.

In this context, the use of software visualization techniques for analysis and recovery of a system architecture is essential, since it allows greater flexibility to the process of modernization. Through this technique, it is possible to obtain a compact representation of the entire structure of the source code. The various aspects of the software implemented in several lines of code may be represented by a single diagram, which summarizes all this complexity.

In addition, an architecture recovery process using clustering techniques is also effective. A representation automatically created by a data collation process is a quick and convenient way to explore complex systems, often totally unknown to the analyst. This is is a good first step to understanding important aspects of the software. In other cases, the clustering process can provide different perspectives in understanding of software functionalities.

To some extent, our work is the first of a kind where we explore the use of both techniques, the visualization and clustering software, to provide a wide range of system representations analysis. Experiment performed our approach can significantly improve the architecture process disregard the programming language or the order of the techniques applied. We believe such representations will allow different views on various aspects of the software, which contributes to the understanding of the whole system structure. Thus, the use of these techniques allows for the recovery of a system architecture, with agility and accuracy. 

For future work, we plan to make a comprehensive analysis on public software repository, e.g. GitHub, and conduct a more thorough empirical study, also considering other programming languages like C or C++.



\bibliographystyle{abbrv}
\bibliography{bibliografia}  % sigproc.bib is the name of the Bibliography in this case


\end{document}
